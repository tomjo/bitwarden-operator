use kube::CustomResource;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

/// Struct corresponding to the Specification (`spec`) part of the `WardenSecret` resource, directly
/// reflects context of the `wardensecrets.tomjo.net.yaml` file to be found in this repository.
/// The `WardenSecret` struct will be generated by the `CustomResource` derive macro.
#[derive(CustomResource, Serialize, Deserialize, Debug, PartialEq, Clone, JsonSchema)]
#[kube(
    group = "tomjo.net",
    version = "v1",
    kind = "WardenSecret",
    plural = "wardensecrets",
    derive = "PartialEq",
    status = "WardenSecretStatus",
    namespaced
)]
pub struct WardenSecretSpec {
    #[serde(alias = "type")]
    pub type_: String,
    pub item: String,
}

#[derive(Clone, Debug, Deserialize, JsonSchema, Serialize, PartialEq)]
pub struct WardenSecretStatus {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub conditions: Vec<ApplyCondition>,
    pub phase: Option<ApplyPhase>,
    pub start_time: Option<String>,
}

#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct ApplyCondition {
    /// This must default to true when in a good state
    pub status: bool,
    /// Error reason type if not in a good state
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    /// One sentence error message if not in a good state
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// This is an extensible enum. Conditions we don't know about get thrown away.
    #[serde(rename = "type")]
    pub type_: ConditionType,
    /// When the condition was last written in a RFC 3339 format in UTC (e.g. 1996-12-19T16:39:57-08:00)
    #[serde(rename = "lastTransitionTime")]
    pub last_transition: String,
}

#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, JsonSchema)]
pub enum ConditionType {
    Ready,

    /// Catch all event that we don't emit (forwards compatible on api side)
    #[serde(other, skip_serializing)]
    Unknown,
}

#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, JsonSchema)]
pub enum ApplyPhase {
    Pending,
    Running,
    Succeeded,
    Failed,

    /// Catch all event that we don't emit (forwards compatible on api side)
    #[serde(other, skip_serializing)]
    Unknown,
}

impl Default for ConditionType {
    fn default() -> Self {
        ConditionType::Unknown
    }
}

pub fn get_api_version() -> &'static str {
    return "tomjo.net/v1";
}
