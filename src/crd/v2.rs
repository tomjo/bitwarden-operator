use kube::CustomResource;
use schemars::JsonSchema;
use serde::{de, Deserialize, Serialize};
use serde_json::Value;

/// Struct corresponding to the Specification (`spec`) part of the `BitwardenSecret` resource, directly
/// reflects context of the `bitwardensecrets.tomjo.net.yaml` file to be found in this repository.
/// The `BitwardenSecret` struct will be generated by the `CustomResource` derive macro.
#[derive(CustomResource, Serialize, Deserialize, Debug, PartialEq, Clone, JsonSchema)]
#[kube(
    group = "tomjo.net",
    version = "v2",
    kind = "BitwardenSecret",
    plural = "bitwardensecrets",
    derive = "PartialEq",
    status = "BitwardenSecretStatus",
    namespaced
)]
pub struct BitwardenSecretSpec {
    #[serde(alias = "type")]
    pub type_: String,
    pub item: String,
}

#[derive(Clone, Debug, Deserialize, JsonSchema, Serialize, PartialEq)]
pub struct BitwardenSecretStatus {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub conditions: Vec<ApplyCondition>,
    #[serde(rename = "startTime")]
    pub start_time: Option<String>,
    #[serde(rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

/// ApplyCondition
///
/// Meant to act like normal kubernetes conditions like PodCondition:
///
///  - lastProbeTime: null
///    lastTransitionTime: "2019-07-31T13:07:30Z"
///    message: 'containers with unready status: [product-config]'
///    reason: ContainersNotReady
///    status: "False"
///    type: ContainersReady
///
/// We do not post lastProbeTime / lastHeartbeatTime because they are expensive.
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct ApplyCondition {
    /// Whether or not in a good state
    ///
    /// This must default to true when in a good state
    #[serde(deserialize_with = "deserialize_status_bool")]
    pub status: ConditionStatus,
    /// Error reason type if not in a good state
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    /// One sentence error message if not in a good state
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,

    /// The type of condition we export
    ///
    /// This is an extensible enum. Conditions we don't know about gets thrown away.
    #[serde(rename = "type")]
    pub type_: ConditionType,

    /// When the condition was last written in a RFC 3339 format
    ///
    /// Format == `1996-12-19T16:39:57-08:00`, but we hardcode Utc herein.
    #[serde(rename = "lastTransitionTime")]
    pub last_transition: String,
}

/// Allowed condition statuses.
///
/// Absence of condition should be interpreted as `Unknown`.
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, JsonSchema)]
pub enum ConditionStatus {
    True,
    False,
    Unknown,
}

fn deserialize_status_bool<'de, D>(deserializer: D) -> Result<ConditionStatus, D::Error>
where
    D: de::Deserializer<'de>,
{
    Ok(match Value::deserialize(deserializer)? {
        Value::Bool(b) => ConditionStatus::from_bool(b),
        Value::String(s) => ConditionStatus::from_str(&s),
        _ => ConditionStatus::Unknown,
    })
}

impl ConditionStatus {
    pub fn from_str(s: &str) -> Self {
        match s {
            "True" => ConditionStatus::True,
            "False" => ConditionStatus::False,
            _ => ConditionStatus::Unknown,
        }
    }

    pub fn to_str(&self) -> String {
        match self {
            ConditionStatus::True => "True",
            ConditionStatus::False => "False",
            ConditionStatus::Unknown => "Unknown",
        }
        .to_string()
    }

    pub fn from_bool(b: bool) -> Self {
        if b {
            ConditionStatus::True
        } else {
            ConditionStatus::False
        }
    }
}

impl Default for ConditionStatus {
    fn default() -> Self {
        ConditionStatus::Unknown
    }
}

/// Allowed condition types we always export all of.
///
/// This does not describe a state machine. We set conditions as they happen.
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, JsonSchema)]
pub enum ConditionType {
    Ready,

    /// Cach all event that we don't emit (forwards compat on api side)
    #[serde(other, skip_serializing)]
    Unknown,
}

impl Default for ConditionType {
    fn default() -> Self {
        ConditionType::Unknown
    }
}

impl BitwardenSecretStatus {
    pub fn is_ready(&self) -> bool {
        for i in 0..self.conditions.len() {
            if self.conditions[i].type_ == ConditionType::Ready {
                return self.conditions[i].status == ConditionStatus::True;
            }
        }
        false
    }
}

impl BitwardenSecret {
    pub fn get_observed_generation(&self) -> Option<i64> {
        return self
            .status
            .as_ref()
            .map(|x| x.observed_generation)
            .flatten();
    }
}

pub fn get_api_version() -> &'static str {
    return "tomjo.net/v2";
}
